#!/usr/bin/env opsh
# shellcheck shell=bash

# Top-level associative array mapping repo name to its nested associative array name
declare -A GIT_REPOSITORIES

# Usage:
# git::repo-add <url> <dir> [--branch=name] [options] [--ssh-secret=SECRET_NAME] [--any_other=val]
# Add a repo
git::repo-add() {
	local url=""
	local dir=""
	local branch=""
	local options=""
	local ssh_secret=""

	# Parse required positional args
	url="$1"
	shift
	dir="$1"
	shift

	# Parse named args
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--branch=*)
			branch="${1#*=}"
			shift
			;;
		--branch)
			branch="$2"
			shift 2
			;;
		--ssh-secret=*)
			ssh_secret="${1#*=}"
			shift
			;;
		--ssh-secret)
			ssh_secret="$2"
			shift 2
			;;
		--options=*)
			options="${1#*=}"
			shift
			;;
		--options)
			options="$2"
			shift 2
			;;
		*)
			echo "Unknown argument: $1" >&2
			return 1
			;;
		esac
	done

	# Derive normalized name from repo
	local name
	name=$(basename -s .git "$url")
	name=${name//-/_}
	# If no branch specified, check env var like TOOLING_BRANCH
	if [[ -z "$branch" ]]; then
		local env_branch_var="${name^^}_BRANCH"
		branch="${!env_branch_var:-main}"
	fi

	local var="REPO_${name}"
	declare -gA "$var"
	declare -n repo="$var"
	repo[url]="$url"
	repo[dir]="$dir"
	repo[branch]="$branch"
	repo[options]="$options"
	[[ -n "$ssh_secret" ]] && repo[ssh_secret]="$ssh_secret"

	GIT_REPOSITORIES["$name"]="$var"
}

# Clone one repo
git::repo-clone() {
	local name="$1"
	# shellcheck disable=SC2178

	declare -n repo="${GIT_REPOSITORIES[$name]}"

	echo "Cloning ${repo[url]} → ${repo[dir]}"
	if [[ -d "${repo[dir]}/.git" ]]; then
		echo "⏩ Already a git repo: ${repo[dir]}"
	else
		local git_env=()
		[[ -n "${repo[ssh_secret]:-}" ]] && git_env=("GIT_CONFIG_GLOBAL=/dev/null" "GIT_SSH_COMMAND=ssh -F $_OPSH_SSH_CONTEXT/config")
		cmd=(env "${git_env[@]}" git clone)
		[[ -n "${repo[options]}" ]] && cmd+=("${repo[options]}")
		cmd+=("${repo[url]}" "${repo[dir]}")
		"${cmd[@]}"
	fi

	if [[ -n "${repo[branch]}" ]]; then
		git -C "${repo[dir]}" checkout "${repo[branch]}"
	fi

	# Set core.hooksPath if .githooks exists
	if [[ -d "${repo[dir]}/.githooks" ]]; then
		git -C "${repo[dir]}" config core.hooksPath .githooks
		echo ":wrench: Set core.hooksPath for ${repo[dir]}"
	fi
}

# Clone all
git::repos-clone() {
	echo "--- :git: Cloning Repositories"
	for name in "${!GIT_REPOSITORIES[@]}"; do
		git::repo-clone "$name" || return 1
	done
}

# Show a summary of repo/branch status in Buildkite style
git::repos-summary() {
	local failed=0
	echo "--- :git: Git Branch Summary"

	for repo_name in "${!GIT_REPOSITORIES[@]}"; do
		local var_name="${GIT_REPOSITORIES[$repo_name]}"
		declare -n repo="$var_name"

		local repo_url="${repo[url]}"
		local branch="${repo[branch]:-main}"

		local git_env=()
		# if we have an ssh-secret defined, assume we are accessing with a key
		# and ignore any repo settings to avoid git url rewrites
		[[ -n "${repo[ssh_secret]:-}" ]] && git_env=("GIT_CONFIG_GLOBAL=/dev/null" "GIT_SSH_COMMAND=ssh -F $_OPSH_SSH_CONTEXT/config")

		if ! read -r commit _ < <(env "${git_env[@]}" git ls-remote "$repo_url" "refs/heads/$branch"); then
			echo "❌ Repo not found: $repo_url"
			failed=1
			continue
		fi

		if [[ -z "$commit" ]]; then
			echo "❌ Branch '$branch' not found in $repo_url"
			failed=1
			continue
		fi

		local commit
		commit=$(env "${git_env[@]}" git ls-remote "$repo_url" "refs/heads/$branch" | awk '{print $1}')
		echo "✅ $repo_name → $branch @ ${commit:0:12}"
	done

	echo -e "^^^ +++\n"
	return $failed
}

# Function to validate a Git repository.  Error are logged via opsh and
# the return status indicates the error.
#
# Usage:
#   git::repo::validate <repo_path>
#
# Returns:
#   0: Success (valid repo, and in sync if --in-sync was given).
#   1: Invalid arguments.
#   2: Not a valid Git repository.
#   3: Local changes not committed.
#   4: Fetch failed (remote not accessible).
#   5: No upstream branch configured.
#   6: Local branch is not in sync (ahead, behind, or diverged).
#   outputs: "repo_name branch_name commits_ahead commits_behind"
#   commits_head/behind = -1 if there is an error

git::repo-validate() {
	local repo_path
	local return_code=0

	# Argument parsing
	if [[ "$#" -eq 0 ]]; then
		log::error "Usage: ${FUNCNAME[0]} <repo_path>" >&2
		return 1
	fi

	for arg in "$@"; do
		if [[ -z "${repo_path:-}" ]]; then
			repo_path="$arg"
		fi
	done

	# Check if the repository path is a valid Git directory
	if [[ ! -d "$repo_path/.git" ]]; then
		log::error "${repo_path} is not a valid Git repository"
		return 2
	fi

	repo_name=$(basename "$repo_path" | tr '[:lower:]' '[:upper:]' | tr -c 'A-Z0-9' '_')
	# remove trailing '_'
	repo_name="${repo_name%"${repo_name##*[!_]}"}"

	# Enter the repository to run git commands
	pushd "$repo_path" >/dev/null || return 1
	local repo_branch
	repo_branch=$(git rev-parse --abbrev-ref HEAD)
	local local_is_ahead
	local local_is_behind
	local_is_ahead=-1
	local_is_behind=-1
	if ! git diff --quiet || ! git diff --cached --quiet; then
		log::error "${repo_path}: Uncommitted changes detected."
		return_code=3
		# Fetch the latest remote info. Suppress output and check for failure.
	elif ! git fetch origin >/dev/null 2>&1; then
		log::error "${repo_path}: Could not fetch from remote. Check network or remote URL"
		return_code=4
	else
		# Check if the branch has an upstream configured.
		if ! git rev-parse --abbrev-ref --symbolic-full-name "@{u}" >/dev/null 2>&1; then
			log::error "${repo_path}: Branch '${repo_branch}' has no upstream configured"
			return_code=5
		else
			# Compare local and remote commits
			local_is_ahead=$(git rev-list --count HEAD "^@{u}")
			local_is_behind=$(git rev-list --count "@{u}" ^HEAD)
			if [[ "$local_is_ahead" -eq 0 && "$local_is_behind" -eq 0 ]]; then
				log::info "${repo_path}: Branch '${repo_branch}' is in sync with remote"
				return_code=0
			elif [[ "$local_is_ahead" -gt 0 || "$local_is_behind" -gt 0 ]]; then
				return_code=6
				if [[ "$local_is_ahead" -gt 0 && "$local_is_behind" -gt 0 ]]; then
					log::error "${repo_path}: Diverged. Ahead by ${local_is_ahead}, behind by ${local_is_behind}"
				elif [[ "$local_is_ahead" -gt 0 ]]; then
					true
					log::error "${repo_path}: Ahead of remote by ${local_is_ahead} commits"
				else
					log::error "${repo_path}: Behind remote by ${local_is_behind} commits"
				fi
			fi
		fi
	fi

	popd >/dev/null || true
	echo -e "${repo_name} ${repo_branch} ${local_is_ahead} ${local_is_behind}"
	return "$return_code"
}
