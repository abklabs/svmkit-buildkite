#!/usr/bin/env opsh
# shellcheck shell=bash

# Top-level associative array mapping repo name to its nested associative array name
declare -A GIT_REPOSITORIES

# Usage:
# git::repo-add <url> <dir> [--branch=name] [options] [--ssh-secret=SECRET_NAME] [--any_other=val]
# Add a repo
git::repo-add() {
	local url=""
	local dir=""
	local branch=""
	local options=""
	local ssh_secret=""

	# Parse required positional args
	url="$1"
	shift
	dir="$1"
	shift

	# Parse named args
	while [[ $# -gt 0 ]]; do
		case "$1" in
		--branch=*)
			branch="${1#*=}"
			shift
			;;
		--branch)
			branch="$2"
			shift 2
			;;
		--ssh-secret=*)
			ssh_secret="${1#*=}"
			shift
			;;
		--ssh-secret)
			ssh_secret="$2"
			shift 2
			;;
		--options=*)
			options="${1#*=}"
			shift
			;;
		--options)
			options="$2"
			shift 2
			;;
		*)
			echo "Unknown argument: $1" >&2
			return 1
			;;
		esac
	done

	# Derive normalized name from repo
	local name
	name=$(basename -s .git "$url")
	name=${name//-/_}
	# If no branch specified, check env var like TOOLING_BRANCH
	if [[ -z "$branch" ]]; then
		local env_branch_var="${name^^}_BRANCH"
		branch="${!env_branch_var:-main}"
	fi

	local var="REPO_${name}"
	declare -gA "$var"
	declare -n repo="$var"
	repo[url]="$url"
	repo[dir]="$dir"
	repo[branch]="$branch"
	repo[options]="$options"
	[[ -n "$ssh_secret" ]] && repo[ssh_secret]="$ssh_secret"

	GIT_REPOSITORIES["$name"]="$var"
}

# Clone one repo
git::repo-clone() {
	local name="$1"
	# shellcheck disable=SC2178

	declare -n repo="${GIT_REPOSITORIES[$name]}"

	echo "Cloning ${repo[url]} → ${repo[dir]}"
	if [[ -d "${repo[dir]}/.git" ]]; then
		echo "⏩ Already a git repo: ${repo[dir]}"
	else
		local git_env=()
		[[ -n "${repo[ssh_secret]:-}" ]] && git_env=("GIT_CONFIG_GLOBAL=/dev/null" "GIT_SSH_COMMAND=ssh -F $_OPSH_SSH_CONTEXT/config")
		cmd=(env "${git_env[@]}" git clone)
		[[ -n "${repo[options]}" ]] && cmd+=("${repo[options]}")
		cmd+=("${repo[url]}" "${repo[dir]}")
		"${cmd[@]}"
	fi

	if [[ -n "${repo[branch]}" ]]; then
		git -C "${repo[dir]}" checkout "${repo[branch]}"
	fi

	# Set core.hooksPath if .githooks exists
	if [[ -d "${repo[dir]}/.githooks" ]]; then
		git -C "${repo[dir]}" config core.hooksPath .githooks
		echo ":wrench: Set core.hooksPath for ${repo[dir]}"
	fi
}

# Clone all
git::repos-clone() {
	echo "--- :git: Cloning Repositories"
	for name in "${!GIT_REPOSITORIES[@]}"; do
		git::repo-clone "$name" || return 1
	done
}

# Show a summary of repo/branch status in Buildkite style
git::repos-summary() {
	local failed=0
	echo "--- :git: Git Branch Summary"

	for repo_name in "${!GIT_REPOSITORIES[@]}"; do
		local var_name="${GIT_REPOSITORIES[$repo_name]}"
		declare -n repo="$var_name"

		local repo_url="${repo[url]}"
		local branch="${repo[branch]:-main}"

		local git_env=()
		# if we have an ssh-secret defined, assume we are accessing with a key
		# and ignore any repo settings to avoid git url rewrites
		[[ -n "${repo[ssh_secret]:-}" ]] && git_env=("GIT_CONFIG_GLOBAL=/dev/null" "GIT_SSH_COMMAND=ssh -F $_OPSH_SSH_CONTEXT/config")

		if ! read -r commit _ < <(env "${git_env[@]}" git ls-remote "$repo_url" "refs/heads/$branch"); then
			echo "❌ Repo not found: $repo_url"
			failed=1
			continue
		fi

		if [[ -z "$commit" ]]; then
			echo "❌ Branch '$branch' not found in $repo_url"
			failed=1
			continue
		fi

		local commit
		commit=$(env "${git_env[@]}" git ls-remote "$repo_url" "refs/heads/$branch" | awk '{print $1}')
		echo "✅ $repo_name → $branch @ ${commit:0:12}"
	done

	echo -e "^^^ +++\n"
	return $failed
}
