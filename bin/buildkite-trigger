#!/usr/bin/env opsh
# shellcheck shell=bash
lib::import common
git_opsh="${SCRIPTDIR}/../lib/git.opsh"

# shellcheck disable=SC1090
source "$git_opsh"

# === Config ===
ORG="svmkit"
COMMIT="HEAD"
BRANCH="${BRANCH:-$(git rev-parse --abbrev-ref HEAD)}"
MESSAGE="Triggered from script"

# === Derived values ===
REPOS=()
ENVS=()
DRY_RUN=false
FORCE=false

usage() {
	cat >&2 <<EOF
Usage: $0 [options] PIPELINE

   Trigger buildkite pipeline for a set of local repos.
   Branch information is pulled from local repos specifed in the --repo
   flag and passed as environment variables to buildkite.  The pipline
   needs to support this convention.  Branch info is passed as
   <REPO>_BRANCH environment variables.

Options:
  -E, --env  var=value  Set an environment varible for the pipeline
  -f, --force		Force trigger even if local repos are out of sync
  -h, --help            Show this help message and exit
  -m, --message <msg>   Set the build message (default: "Triggered from script")
  -n, --dry-run         Print the API call instead of triggering the build
  -r, --repo <path>	Include the given repo (can be used multiple times)
EOF
}

while [[ $# -gt 0 ]]; do
	case "$1" in
	-r | --repo)
		REPOS+=("$2")
		shift 2
		;;
	-E | --env)
		ENVS+=("$2")
		shift 2
		;;
	-n | --dry-run)
		DRY_RUN=true
		shift
		;;
	-f | --force)
		FORCE=true
		shift
		;;
	-m | --message)
		MESSAGE="$2"
		shift 2
		;;
	-h | --help)
		usage
		exit 0
		;;
	--* | -*)
		log::fatal "Unknown option: $1" >&2
		;;
	*)
		[[ -n "${PIPELINE:-}" ]] && log::fatal "Error: Multiple pipeline names specified: '$PIPELINE' and '$1'" >&2
		PIPELINE="$1"
		shift
		;;
	esac
done

if [[ -z "${PIPELINE:-}" ]]; then
	usage
	exit 1
fi

# Check for valid env syntax before we move on
# Basically VAR=.*
envs_ok=true
for env in "${ENVS[@]}"; do
	if [[ ! "$env" =~ ^[^[:space:]=]+=.*$ ]]; then
		echo "Error: invalid environment variable definition '$env'" >&2
		envs_ok=false
	fi
done
$envs_ok || exit 1

# === Collect env vars ===
declare -A env_map

out_of_sync=0
for repo_path in "${REPOS[@]}"; do
	if [[ -d "$repo_path/.git" ]]; then
		pushd "$repo_path" >/dev/null
		output="$(git::repo::validate "$repo_path")" || ((out_of_sync += 1))
		IFS=' ' read -r repo_name repo_branch _ <<<"$output"
		branch_env_var=$(git::repo::branch-var "$repo_name")
		env_map["$branch_env_var"]="$repo_branch"
		popd >/dev/null
	else
		log::error "$repo_path is not a valid Git repository"
		((out_of_sync += 1))
	fi
done

# Add the command line definitions.
for env in "${ENVS[@]}"; do
	key=${env%%=*}
	val=${env#*=}
	env_map["$key"]="$val"
done

if [[ "$FORCE" == false && "$out_of_sync" -gt 0 ]]; then
	echo "$out_of_sync repositories are out of sync."
	exit 1
fi

# === Convert to JSON ===
ENV_VARS_JSON="{"
first=true
for key in "${!env_map[@]}"; do
	[[ $first == true ]] && first=false || ENV_VARS_JSON+=","
	val=${env_map[$key]}
	if [[ $val == null ]]; then
		ENV_VARS_JSON+="\"$key\": null"
	else
		escaped=$(jq -Rn --arg v "$val" '$v')
		ENV_VARS_JSON+="\"$key\": ${escaped}"
	fi
done
ENV_VARS_JSON+="}"

# === Output or Trigger ===
build_payload=$(
	jq -n \
		--arg commit "$COMMIT" \
		--arg branch "$BRANCH" \
		--arg message "$MESSAGE" \
		--argjson env "$ENV_VARS_JSON" \
		'{
	    "commit": $commit,
	    "branch": $branch,
	    "message": $message,
	    "env": $env
	  }'
)

curl_cmd=(
	curl -s -X POST
	"https://api.buildkite.com/v2/organizations/$ORG/pipelines/$PIPELINE/builds"
	-H "Authorization: Bearer ${BUILDKITE_API_TOKEN:-BUILDKITE_API_TOKEN_NOT_SET}"
	-H "Content-Type: application/json"
	-d "$build_payload"
)

if $DRY_RUN; then
	echo "${curl_cmd[@]/${BUILDKITE_API_TOKEN}/\$BUILDKITE_API_TOKEN}"
else
	response=$(temp::file)
	"${curl_cmd[@]}" >"$response"
	build_url=$(jq -r '.web_url' <"$response")

	if [[ $build_url == null ]]; then
		log::error "Build failed"
		cat "$response"
	else
		log::info "Build triggered: $build_url"
	fi
fi
